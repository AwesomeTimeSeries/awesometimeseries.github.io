---
layout: default
title: 循环语句
nav_order: 2
parent: 逻辑结构
---

# repeat语句

repeat结构是最简单的一种循环结构：

```c
repeat(循环次数)
{
    循环体
}
```

例如：

```c
repeat(30)
    instance_create(x, y, objBullet);
```

这将导致创建30个objBullet。

# while语句

while语句是用以循环执行某一段代码的语句，其格式为：

```c
while(判定条件)
{
    语句1;
    语句2;
    ...
}
```

只要while后小括号里的值判定为1，就会循环不断地执行花括号里的代码（正数一律视为1）。所以，这个循环必须要有办法能够停止。如：

```c
i = 1;
s = 0;
while(i <= 100)
{
    s += i;
    i += 1;
}
show_message(string(s));
```

这段代码用来计算1+2+3+...+100的和并将值存在变量s中。

每一次执行花括号中的代码，变量i的值就会在自身的基础上再加一，只要i小于等于100，就满足while的判定，就会再一次执行花括号内的代码。由于GM的代码执行是从上往下按顺序执行，所以循环结束之前，后面的`show_message(string(s));`是不会执行的。当i增加到101时，`i <= 100`不成立，不满足while的判定，循环终止，这时才会执行后面的`show_message(string(s));`代码。

PS：`show_message(string(s));`这句代码用来弹出一个弹窗，并且将s的值显示在弹窗中。

# do语句

do语句也是用以循环执行代码段的语句，其格式为：

```c
do
{
    语句1;
    语句2;
    ...
}
until(判定条件)
```

与while相反，该语句只有until后小括号内的**判定条件为0**时才会循环执行。将while语句改为do语句，判定条件要刚好相反。

如，将上面while语句的例子改为do语句，就变成了：

```c
i = 1;
s = 0;
do
{
    s += i;
    i += 1;

}
until(i > 100)    //此处条件与while相反
show_message(string(s));
```

*扩展：*

while和do的机制上有差别，即while语句先判定后执行代码段，而do语句是先执行代码段后判定。

在循环至少会执行一次时，while与do是没有区别的。二者的区别在于当判定条件一次都不满足时。如：

```c
i = 5;
while(i <= 0)
{
    i += 1;
}
show_message(string(i));
```

与

```c
i = 5;
do
{
    i += 1;
}
until(i > 0)
show_message(string(i));
```

显然，i = 5是不满足`i <= 0`，所以while语句中的代码段是不会执行的，i的值依然是5。但是在do语句中，是先执行`i += 1`，然后再判定`i > 0`的，此时i = 6，6 > 0，循环终止，所以最后输出的i的值是6。

只要循环的判定条件至少能满足一次以上，while和do是一样的效果，差别仅体现在判定条件一次都满足不了的情况下。

# for语句

for语句是第三种循环语句。其格式为：

```c
for(语句1; 判定条件; 语句n)
{
    语句2;
    语句3;
    ...
    语句n-1;
}
```

for语句和while语句可以完全相互替代，将上述for语句改为while语句，就是：

```c
语句1;
while(判定条件)
{
    语句2;
    语句3;
    ...
    语句n-1;
    语句n;
}
```

for语句的好处在于可以将用于控制循环的变量的赋值、判定、自增放在一起，便于阅读。

如，之前举的while的例子：

```c
i = 1;
s = 0;
while(i <= 100)
{
    s += i;
    i += 1;
}
show_message(string(s));
```

将其改为for语句，就是：

```c
s = 0;
for(i = 1; i <= 100; i += 1)
    s += i;
show_message(string(s));
```

使用for语句将用于控制循环的变量i全部放在一行中，便于阅读。

for循环中的变量i也可以被主体所使用。

# break语句

break语句的作用是**终止整个循环**。

例如，上述while的例子，你可以改成：

```c
i = 1;
s = 0;
while(true)
{
    s += i;
    i += 1;
    if(i > 100)
        break;
}
show_message(string(s));
```

效果是一样的。

把for语句改成使用break终止循环，如上述例子可以改成：

```c
s = 0;
for(i = 1; true; i += 1)
{
    s += i;
    if(i > 100)
        break;
}
show_message(string(s));
```

break一般写在if语句中，否则第一次循环就会执行break中断循环。一个循环中可以写多个break，如：

```c
s = 0;
for(i = 1;;i += 1)
{
    s += i;
    if(i > 100)
        break;
    if(s > 1000)
        break;
}
show_message(string(s));
```

注意，break语句只能中断一层循环。如：

```c
h = 0;
for(i = 1; i <= 100; i += 1)
{
    for(j = 1; j <= 100; j += 1)
    {
        h += i + j;
        if(j > i)
             break;
    }
}
```

第一次循环时：i = 1，j = 1，h = 0 + i + j = 2，内层for语句继续循环：i = 1，j = 2，h = 2+i+j = 5，此时j > i，执行break，注意此时程序只会从第二层循环跳到第一层循环，而不是终止整个循环。跳到第一层循环后，`i += 1`，故i = 2，仍然满足`i <= 100`，所以再次进入到第二层循环。

# continue语句

continue语句的作用是使循环体**跳过一次代码执行**。

举个例子来理解：

```c
s = 0;
for(i = 1; i <= 100; i += 1)
    s += i;
```

这是计算1+2+3+...+100的和的代码，如果你要从中去除30，你可以这样写：

```c
s = 0;
for(i = 1; i <= 100; i += 1)
{
    if(i == 30)
        continue;
    s += i;
}
```

这样当i为30时，执行continue，会跳过本次`s += i`，但是并不会终止整个循环，而是i再自增变成31，再进行下一次循环。

注意，由于代码是从上往下执行，所以*continue只能跳过位于自己下方的代码*。如：

```c
s = 0;
t = 0;
for(i = 1; i <= 100; i += 1)
{
    t += i;
    if(i == 30)
        continue;
    s += i;
}
```

在这里，continue对`t += i`无法产生影响，t的最终值是1+2+3+...+100 = 5050，而s的最终值是1+2+3+...+29+31+32+...+100 = 5020。
