---
layout: default
title: 堆栈
nav_order: 1
parent: 数据结构
---

**堆栈**（stack）是一种“**先入后出，后入先出**”的数据结构。想象你要搬家了，你把自己的上百本书装进一个箱子里带走，当你到新家的时候，你要把书拿出来，你拿出来的第一本书，是不是你之前装入的最后一本书？而你拿出来的最后一本书，是不是你之前装入的第一本书？堆栈就是这么一种性质，当你向堆栈中加入数据时，数据会被放在顶层，当你要获取数据时，也只能获取顶层的数据。你必须要先移除顶层的数据，才能去访问下一个顶层的数据，并且数据一旦移除就会永久消失。

* `ds_stack_create()` 创建一个堆栈，返回它的索引。
* `ds_stack_destroy(id)` 销毁索引为id的堆栈。一旦你使用完，一定要销毁数据结构释放内存。
* `ds_stack_clear(id)` 清空索引为id的堆栈内所有数据。
* `ds_stack_copy(dest, src)` 将索引为src的堆栈的数据拷贝到索引为dest的堆栈中。
* `ds_stack_size(id)` 返回索引为id的堆栈储存了多少个数据。
* `ds_stack_empty(id)` 返回索引为id的堆栈是否为空。
* `ds_stack_push(id, val)` 加入一个数值到叫作这个标识符的堆栈。
* `ds_stack_pop(id)` 返回叫作这个标识符的堆栈最新加入的数值，并移除这个数值。
* `ds_stack_top(id)` 返回叫作这个标识符的堆栈最新加入的数值，但不移除这个数值。
* `ds_stack_write(id)` 将索引为id的堆栈转换为字符串，返回这个字符串。通常用于储存到文件中。
* `ds_stack_read(id, str)` 从字符串str中读取堆栈。与上面这个函数配对，用于从文件中读取堆栈。

通常，堆栈并不适合开发者去使用，他更多地用在程序本身的优化上，比如函数的递归。所谓递归，就是函数的自我调用，在函数内部的代码中调用自己本身，并且使用了函数的返回值，或者两个函数之间互相调用。当然，这个调用必须要有一个if来控制结束，否则会无限调用。通常程序在处理递归时就会使用堆栈，每一次的函数调用都会占据一层堆栈，直到最后一层函数处理完毕，被移除，返回值交给倒数第二层函数，以此类推。
