---
layout: default
title: 运算
nav_order: 2
parent: 变量
---

# 算术运算

GM8 除了支持除了基本的**加减乘除**外，还有一些其他运算方式如下：

`mod`：求余/求模。用法：`x mod y`，求 x 除以 y 的余数。

`div`：取整。用法：`x div y`，求 x 除以 y 的商。

`&`、`|`、`^`、`~`、`>>`、`<<` 均为[位运算]({{ site.baseurl }}{% link _tutorials/binary/bitwise.md %}#位运算)的运算符，实际上几乎不会使用到这些运算。

但如果你要计算幂，不能使用类似 `3^2` 的格式，因为这个在 GM 里是位运算而不是幂运算。要想计算幂需要使用幂函数 `power`。计算 3² 应该写成 `power(3, 2);`。

---

GM提供了一些简便的赋值运算符，他们是由基本运算符和赋值等号组成的，如：`+=`、`-=`、`*=`、`/=` 等。

他们表示省略自身的赋值运算，如：

```c
dep = 16;
dep += 12;
```

后一句的意思是，dep 这个变量在自身的基础上增加 12，相当于 `dep = dep + 12;`，最终 dep 值为 28。

其余也是同理。

要注意的是使用带乘或除的赋值等号时，如：

```c
num1 = 12;
num2 = 5;
num3 = 20;
num3 *= num2 + num1;
```

最后一句相当于是 `num3 = num3 * (num2 + num1);` 而不是 `num3 = num3 * num2 + num1;`。

# 逻辑运算

逻辑运算是一种特殊的运算，他只能计算得到两个值：1 或者 0。

1 和 0 即是“真”和“假”两个概念在编程中的象征。即，规定当条件为“真”时，用 1 表示，当条件为“假”时，用 0 表示。

因为逻辑演算是由布尔建立的，所以逻辑运算又被称为**布尔运算**，“真”与“假”被称为**布尔值**。

逻辑运算的符号有：`>`（大于号），`<`（小于号），`==`（逻辑等号），`>=`（大于或等于号），`<=`（小于或等于号），`!=`（不等号），`&&`（逻辑与，可用 `and` 代替），`||`（逻辑或，可用 `or` 代替），`^^`（逻辑异或，可用 `xor` 代替），`!`（逻辑非，可用 `not` 代替）。

注意逻辑运算的 `&&`，`||`，`^^` 不能只写一个符号，必须写两个。写一个是位运算。

逻辑运算的格式为 `x 逻辑运算符 y`，与常规的运算符相同。

当 x 和 y 满足判定条件时，值为 1，不满足时值为 0。

如：

```c
a = 3 > 2;
```

显然 `3 > 2` 成立，故 a 的值为 1。

```c
b = 16 == 12 + 5;
```

显然 `16` 和 `12 + 5` 并不相等，故 b 的值为 0。

其余逻辑运算均同理。

逻辑与、或、异或用于连接不同的逻辑判定，如：

```c
a = 3 > 2 && 5 > 4;
```

或：

```c
a = 3 > 2 and 5 > 4;
```

此时 `3 > 2` 成立，计算结果为 1，`5 > 4` 也成立，计算结果也是 1，所以 a 的值为 1。

* **`&&`（或 `and`）**表示只有两边都为 1 时才为 1，任何一边为 0 都得到 0。
* **`||`（或 `or`）**表示任何一边为 1 就为 1，只有都为 0 时值才为 0。
* **`^^`（或 `xor`）**表示一边是 1 一边是 0 时得到 1，两边值都是 1 或都是 0 时得到 0。

**逻辑非（`!` 或 `not`）**表示颠倒 0 和 1，如：

```c
b = !a;
```

若 a 为 0，则 b 为 1；若 a 为 1，则 b 为 0。（在 GM 中，当 a>=0.5 时视为真，`!a` 等于 0；当 a<0.5 时视为假，`!a` 等于 1）

注意 `!` 的优先级非常高，如：

```c
a = !3 > 4;
```

这里是先执行 `!3` 得到 0，之后再执行 `0 > 4` 得到 0，结果 a 为 0。

所以要想让 `3 > 4` 先执行，就要使用括号：

```c
a = !(3 > 4);
```

结果 a 为 1。

当出现数量较多的逻辑与、或、亦或时，按照从左到右的顺序执行，如：

```c
a = 16 > 5 && 24 != 13 * 5 || 16 + 8 < 11;
```

为了方便阅读，建议加上括号：

```c
a = (16 > 5) && (24 != 13 * 5) || (16 + 8 < 11);
```

先执行 `(16 > 5) && (24 != 13 * 5)`，计算结果是 1，然后再执行 `1 || (16 + 8 < 11)`，计算结果是 1。

*注：GM 自带了两个常量 **true** 和 **false**，值分别是 1 和 0。在逻辑判断的时候，可以用 true 和 false 代替 1 和 0，以便于代码的阅读。*

如果你搞不清运算符之间的优先度，你可以给所有不确定的地方都打上括号，括号的优先度是最高的。
